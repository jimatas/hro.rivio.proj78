/*
 * Proj7-8:  DOM Level 1 implementation
 * 
 * K. Atas <0712593@student.hro.nl>
 * H.J. Bos <0779473@student.hro.nl>
 */

package proj78.xml.parser;

import java.util.Map;
import java.util.Map.Entry;

import proj78.xml.XmlCDataSection;
import proj78.xml.XmlDocument;
import proj78.xml.XmlElement;
import proj78.xml.XmlNode;
import proj78.xml.XmlText;
import proj78.xml.XmlUtility;

/**
 * Builds a DOM tree step-by-step, by translating the parse events that are 
 * generated by an XML parser into node creation calls. The nodes that are 
 * created this way are inserted into the document that was supplied to the
 * constructor.
 * 
 * @author K.A., copyright (c) 2008
 */
public class XmlDocumentBuilder implements XmlParseEventListener {
	/**
	 * The current (i.e., active) node.
	 */
	private XmlNode currentNode;
	
	/**
	 * Constructs a new instance of the <code>XmlDocumentBuilder</code> class.
	 * 
	 * @param doc the document in which the DOM tree will be built.
	 */
	public XmlDocumentBuilder(XmlDocument doc) {
		currentNode = doc;
		while (currentNode.hasChildNodes()) { // Clear any existing child nodes first.
			currentNode.removeChild(currentNode.getFirstChild());
		}
	}
	
	/** 
	 * Called by the parser when the XML declaration of the document is parsed. 
	 * Creates an <code>XmlDeclaration</code> object and inserts it into the DOM 
	 * tree being constructed.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onXmlDeclaration(java.lang.String, java.lang.String, java.lang.String)
	 */
	public void onXmlDeclaration(String version, String encoding, String standalone) {
		if (currentNode.getNodeType() != XmlNode.DOCUMENT_NODE || currentNode.hasChildNodes()) {
			throw new XmlParseException("Markup before XML declaration.");
		}
		currentNode.appendChild(((XmlDocument)currentNode).getDomImplementation()
				.createXmlDeclaration(version, encoding, standalone));
	}
	
	/**
	 * Called by the parser when the DOCTYPE declaration is parsed. Creates an 
	 * <code>XmlDocumentType</code> object and inserts it into the DOM tree 
	 * being constructed.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onDoctype(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
	 */
	public void onDoctype(String dtdName, String publicId, String systemId, String internalSubset) {
		if (currentNode.getNodeType() != XmlNode.DOCUMENT_NODE 
				|| (currentNode.hasChildNodes() 
						&& currentNode.getLastChild().getNodeType() != XmlNode.PROCESSING_INSTRUCTION_NODE
						&& currentNode.getLastChild().getNodeType() != XmlNode.COMMENT_NODE)) {
			throw new XmlParseException("Markup before DOCTYPE declaration.");
		}
		currentNode.appendChild(((XmlDocument)currentNode).getDomImplementation()
				.createDocumentType(dtdName, publicId, systemId, internalSubset));
	}
	
	/**
	 * Called by the parser when the starting tag of an element is parsed. 
	 * Creates an <code>XmlElement</code> object and inserts it into the DOM 
	 * tree being constructed.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onTagStart(java.lang.String, java.util.Map)
	 */
	public void onTagStart(String tagName, Map<String, String> attrs) {
		XmlElement elem;
		if (currentNode.getNodeType() == XmlNode.DOCUMENT_NODE) {
			elem = ((XmlDocument)currentNode).createElement(tagName);
		} else {
			elem = currentNode.getOwnerDocument().createElement(tagName);
		}
		for (Entry<String, String> attr : attrs.entrySet()) {
			elem.setAttribute(attr.getKey(), attr.getValue());
		}
		currentNode = currentNode.appendChild(elem);
	}
	
	/**
	 * Called by the parser when the ending tag of an element is parsed. Moves 
	 * up one level, to the parent of the current node, making it the active 
	 * node.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onTagEnd(java.lang.String)
	 */
	public void onTagEnd(String tagName) {
		if (!currentNode.getNodeName().equals(tagName)) {
			throw new XmlParseException(String.format("Mismatched tag name '%s'; '%s' expected.", tagName, currentNode.getNodeName()));
		}
		currentNode = currentNode.getParentNode();
	}
	
	/**
	 * Called by the parser when text (i.e., any character data other than 
	 * CDATA) is parsed. Creates an <code>XmlText</code> object and inserts 
	 * it into the DOM tree being constructed.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onCharacters(java.lang.String)
	 */
	public void onCharacters(String chars) {
		if (currentNode.hasChildNodes() && currentNode.getLastChild().getNodeType() == XmlNode.TEXT_NODE) {
			((XmlText)currentNode.getLastChild()).appendData(chars);
		} else if (currentNode.getNodeType() != XmlNode.DOCUMENT_NODE) {
			currentNode.appendChild(currentNode.getOwnerDocument().createTextNode(chars));
		} else if (!XmlUtility.isWhitespace(chars)) {
			currentNode.appendChild(((XmlDocument)currentNode).createTextNode(chars));
		}
	}
	
	/**
	 * Called by the parser when a CDATA-section is parsed. Creates an 
	 * <code>XmlCDataSection</code> object and inserts it into the DOM tree 
	 * being constructed.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onCDataSection(java.lang.String)
	 */
	public void onCDataSection(String content) {
		if (currentNode.hasChildNodes() && currentNode.getLastChild().getNodeType() == XmlNode.CDATA_SECTION_NODE) {
			((XmlCDataSection)currentNode.getLastChild()).appendData(content);
		} else {
			if (currentNode.getNodeType() == XmlNode.DOCUMENT_NODE) {
				currentNode.appendChild(((XmlDocument)currentNode).createCDataSection(content));
			} else {
				currentNode.appendChild(currentNode.getOwnerDocument().createCDataSection(content));
			}
		}
	}
	
	/**
	 * Called by the parser when an XML comment is parsed. Creates an 
	 * <code>XmlComment</code> object and inserts it into the DOM tree being 
	 * constructed.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onComment(java.lang.String)
	 */
	public void onComment(String content) {
		if (currentNode.getNodeType() == XmlNode.DOCUMENT_NODE) {
			currentNode.appendChild(((XmlDocument)currentNode).createComment(content));
		} else {
			currentNode.appendChild(currentNode.getOwnerDocument().createComment(content));
		}
	}
	
	/**
	 * Called by the parser when a processing instruction is parsed. Creates an 
	 * <code>XmlProcessingInstruction</code> object and inserts it into the DOM 
	 * tree being constructed.
	 * 
	 * @see proj78.xml.parser.XmlParseEventListener#onProcessingInstruction(java.lang.String, java.lang.String)
	 */
	public void onProcessingInstruction(String target, String data) {
		if (currentNode.getNodeType() == XmlNode.DOCUMENT_NODE) {
			currentNode.appendChild(((XmlDocument)currentNode).createProcessingInstruction(target, data));
		} else {
			currentNode.appendChild(currentNode.getOwnerDocument().createProcessingInstruction(target, data));
		}
	}
}